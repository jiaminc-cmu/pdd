[
  {
    "reason": "Provides reusable logging, error handling, and type utilities used across all modules",
    "description": "This module serves as the foundational utility layer for the edit-file tool, offering shared functionality such as structured logging, exception formatting, and type-safe helpers. It ensures consistent behavior and error reporting across the codebase, reducing duplication and improving maintainability.\n\nThe module includes a configurable async-safe logger, custom exception classes for tool-specific errors, and utility functions for validating file paths, checking model compatibility, and formatting cost metrics. It also defines common type aliases and constants used throughout the system.\n\nAll other components depend on this module for logging, error propagation, and type annotations. It has no dependencies itself, making it the first module to be implemented. It also provides decorators for retry logic and performance timing, which are used in API and cache layers.\n\nBy centralizing these utilities, the module enables consistent diagnostics, simplifies debugging, and supports future enhancements like structured logging or telemetry integration.",
    "dependencies": [],
    "filename": "utils.py",
    "path": "edit_file_tool/utils.py",
    "priority": 1,
    "component_type": "utility"
  },
  {
    "reason": "Handles all file I/O operations including safe reads, writes, backups, and encoding",
    "description": "This module provides a robust abstraction for interacting with the local filesystem, ensuring safe and consistent file operations across the tool. It is responsible for reading and writing files, creating backups, validating paths, and handling encoding issues.\n\nIt includes async-compatible functions for reading file contents, writing changes, and restoring from backups. It also supports line-based access, which is essential for insert and replace operations. The module ensures atomic writes and includes safeguards against overwriting critical files.\n\nIt depends only on the utility module for logging and error handling. All higher-level components such as the editor tool, cache manager, and core orchestrator rely on this module to access and modify files safely.\n\nThe module also supports line-numbered views for Claude's `view` command and provides helpers for calculating file size and complexity metrics used in caching decisions.",
    "dependencies": ["edit_file_tool/utils.py"],
    "filename": "file_io.py",
    "path": "edit_file_tool/file_io.py",
    "priority": 2,
    "component_type": "core"
  },
  {
    "reason": "Implements the Claude API client with support for tool use, model selection, and cost tracking",
    "description": "This module encapsulates all interactions with the Anthropic Claude API, including message construction, tool registration, model selection, and cost tracking. It provides a high-level async interface for sending prompts and receiving responses, abstracting away the underlying HTTP and SDK details.\n\nIt supports multiple Claude models, including version validation for tool compatibility (e.g., text_editor_20250124). It also integrates with Anthropic's native prompt caching and tracks token usage and cost per request. The module includes logic for injecting the think tool and editor tool definitions into API calls.\n\nIt depends on the utility module for logging and error handling. It is used by the editor tool, core orchestrator, and cache manager to send requests and receive structured responses from Claude.\n\nAdvanced features include support for streaming, retry logic, and cost breakdowns for cache reads/writes. It also provides model metadata for benchmarking and compatibility checks.",
    "dependencies": ["edit_file_tool/utils.py"],
    "filename": "claude_api.py",
    "path": "edit_file_tool/claude_api.py",
    "priority": 3,
    "component_type": "api"
  },
  {
    "reason": "Implements the text editor tool interface for Claude's tool use system",
    "description": "This module defines the implementation of the text_editor_20250124 tool, enabling Claude to perform file edits via structured tool calls. It supports commands such as view, insert, str_replace, create, and undo_edit, and executes them against the local filesystem.\n\nThe module includes a class that maps tool input schemas to corresponding file operations, using the file_io module for safe execution. It validates tool inputs, ensures unique matches for replacements, and returns structured results or error messages to Claude.\n\nIt depends on the Claude API client for tool registration, the file_io module for file access, and the utility module for logging and error handling. It is used by the core orchestrator and can also be invoked directly via the Python API.\n\nThe module supports advanced features like line-numbered views, undo support (for compatible models), and error recovery. It is optimized for performance and correctness, ensuring that edits are applied safely and deterministically.",
    "dependencies": ["edit_file_tool/utils.py", "edit_file_tool/file_io.py", "edit_file_tool/claude_api.py"],
    "filename": "editor_tool.py",
    "path": "edit_file_tool/editor_tool.py",
    "priority": 4,
    "component_type": "tool"
  },
  {
    "reason": "Implements the think tool interface to enable Claude's structured reasoning",
    "description": "This module defines the implementation of the think tool, which provides Claude with a dedicated space for structured reasoning during complex editing tasks. It enables Claude to externalize planning steps, improving token efficiency and edit quality.\n\nThe module registers the think tool with the Claude API and handles tool_use requests by logging and returning the thought content. It does not modify files but plays a critical role in multi-step edits and policy-heavy workflows.\n\nIt depends on the Claude API client for tool registration and the utility module for logging. It is used by the core orchestrator and editor tool to support complex edit sessions.\n\nThe module supports performance benchmarking and includes logic to track when the think tool is used. It is optimized for compatibility with Claude 3.7+ models and integrates seamlessly with the prompt caching system.",
    "dependencies": ["edit_file_tool/utils.py", "edit_file_tool/claude_api.py"],
    "filename": "think_tool.py",
    "path": "edit_file_tool/think_tool.py",
    "priority": 5,
    "component_type": "tool"
  },
  {
    "reason": "Parses natural language edit instructions into structured edit operations",
    "description": "This module is responsible for interpreting user-provided natural language instructions and converting them into structured edit commands that Claude can execute. It supports a wide range of edit types including replacements, insertions, deletions, and multi-step edits.\n\nThe parser uses pattern matching and heuristics to identify line numbers, keywords, and edit intents. It outputs a structured representation of the edit request, which is then passed to the Claude API or editor tool. It also supports enhanced insert detection and multi-edit decomposition.\n\nIt depends on the utility module for logging and the editor tool for command validation. It is used by the core orchestrator and CLI to preprocess user input before invoking Claude.\n\nThe module is optimized for accuracy and robustness, handling ambiguous instructions and providing fallback strategies. It also supports benchmarking and can be tested independently without API access.",
    "dependencies": ["edit_file_tool/utils.py", "edit_file_tool/editor_tool.py"],
    "filename": "instruction_parser.py",
    "path": "edit_file_tool/instruction_parser.py",
    "priority": 6,
    "component_type": "parser"
  },
  {
    "reason": "Manages prompt caching logic and cost optimization using Anthropic's native cache",
    "description": "This module implements the caching layer that integrates with Anthropic's native prompt caching system. It determines when and how to apply caching based on file size, complexity, and user preferences, optimizing for cost and performance.\n\nIt includes logic for auto-detection thresholds (1KB, 4KB), complexity scoring, and cache control injection into Claude API requests. It also calculates cost savings and tracks cache read/write operations for reporting.\n\nIt depends on the Claude API client for cache control integration, the file_io module for file metrics, and the utility module for logging and cost formatting. It is used by the core orchestrator and CLI to manage caching behavior.\n\nThe module supports all cache modes (auto, always, never), handles TTLs, and provides detailed cost breakdowns. It is benchmarked for up to 53% cost savings and is critical for large file support and multi-edit sessions.",
    "dependencies": ["edit_file_tool/utils.py", "edit_file_tool/file_io.py", "edit_file_tool/claude_api.py"],
    "filename": "cache_manager.py",
    "path": "edit_file_tool/cache_manager.py",
    "priority": 7,
    "component_type": "cache"
  },
  {
    "reason": "Coordinates the full edit workflow including parsing, tool use, caching, and Claude interaction",
    "description": "This module serves as the core orchestrator for the edit-file tool, managing the end-to-end workflow from user input to file modification. It integrates instruction parsing, caching, Claude API calls, and tool execution into a cohesive async pipeline.\n\nIt exposes the main edit_file() function used by both the CLI and Python API. It handles retries, max iterations, error recovery, and cost tracking. It also manages model selection, cache mode resolution, and verbose output formatting.\n\nIt depends on all lower-level components: utils, file_io, claude_api, editor_tool, think_tool, instruction_parser, and cache_manager. It is the central hub that coordinates all interactions and ensures consistent behavior.\n\nThe module supports advanced features like multi-model support, structured cost reporting, and think tool integration. It is optimized for performance and reliability, with safeguards against token overflows and infinite loops.",
    "dependencies": [
      "edit_file_tool/utils.py",
      "edit_file_tool/file_io.py",
      "edit_file_tool/claude_api.py",
      "edit_file_tool/editor_tool.py",
      "edit_file_tool/think_tool.py",
      "edit_file_tool/instruction_parser.py",
      "edit_file_tool/cache_manager.py"
    ],
    "filename": "core.py",
    "path": "edit_file_tool/core.py",
    "priority": 8,
    "component_type": "core"
  },
  {
    "reason": "Implements the command-line interface for invoking the edit-file tool",
    "description": "This module provides the CLI entry point for the edit-file tool, allowing users to invoke file edits from the terminal using natural language instructions. It parses command-line arguments, configures the edit session, and displays results.\n\nIt supports options for model selection, cache mode, verbosity, and max iterations. It invokes the core orchestrator and displays cost breakdowns, success messages, or error details. It also supports benchmarking and debug output.\n\nIt depends on the core orchestrator and all lower-level components. It uses argparse or click for argument parsing and the utility module for logging and formatting.\n\nThe CLI is optimized for usability and scriptability, supporting environment variable configuration and exit codes. It is the primary interface for most users and is tested across a wide range of scenarios.",
    "dependencies": ["edit_file_tool/core.py"],
    "filename": "cli.py",
    "path": "edit_file_tool/cli.py",
    "priority": 9,
    "component_type": "core"
  },
  {
    "reason": "Defines the package structure and entry points for distribution via PyPI",
    "description": "This module defines the package metadata, dependencies, and entry points for the edit-file tool, enabling installation via pip and execution via the edit-file command. It ensures the tool is discoverable and installable as a Python package.\n\nIt includes setup configuration (e.g., pyproject.toml or setup.py), specifies required Python version and dependencies (e.g., anthropic SDK), and registers the CLI entry point. It also includes versioning and license metadata.\n\nIt depends on the CLI module for the entry point and includes all other modules as part of the package. It is used during installation and distribution.\n\nThe module is optimized for compatibility with modern packaging standards (PEP 517/518) and supports editable installs for development. It enables publishing to PyPI and integration with tools like pipx or poetry.",
    "dependencies": ["edit_file_tool/cli.py"],
    "filename": "pyproject.toml",
    "path": "edit_file_tool/pyproject.toml",
    "priority": 10,
    "component_type": "package"
  }
]