- The generated file should be a complete, runnable Python script that serves as a thorough usage example for the component.
- The example script should be saved to the location specified by the output path.
- The script should import the necessary functions and classes directly from the module being demonstrated.
- **CRITICAL PROJECT STRUCTURE REQUIREMENTS:**
  - The example file will be located at `examples/module_example.py` (where "module" is the name of the component being demonstrated)
  - The corresponding source code will be located at `edit_file_tool/module.py`
  - **IMPORT STATEMENTS**: Use absolute imports from the edit_file_tool package: `from edit_file_tool.module import function_name`
  - **EXECUTION CONTEXT**: Examples should be designed to run from the project root directory (PDD_user_experience_test_manual)
  - **MODULE DISCOVERY**: Always include sys.path manipulation at the top of the example to ensure imports work from project root:
    ```python
    import sys
    from pathlib import Path
    # Add project root to Python path for imports
    project_root = Path(__file__).parent.parent
    if str(project_root) not in sys.path:
        sys.path.insert(0, str(project_root))
    ```
- The core logic should be encapsulated in a main function (e.g., `demonstrate_operations()`).
- **CRITICAL PYTHON SYNTAX RULE**: When defining functions, use proper Python syntax with ONLY ONE "def" keyword (e.g., `def function_name():`, NOT `def def function_name():`). This is a COMMON ERROR that breaks the code - always double-check function definitions and avoid duplicating the "def" keyword.
- Use extensive `print()` or `logging` statements to clearly explain each step of the demonstration as it runs.
- The script must demonstrate the component's primary features and common use cases.
- It should also include examples of how to correctly handle expected errors using `try...except` blocks, showcasing any custom exceptions the module provides.
- If the script creates any files or directories, it must clean them up before exiting, typically using a `try...finally` block.
- The script must ONLY use ASCII characters (no unicode symbols, emojis, checkmarks, or special characters) to avoid encoding errors during execution on different systems.
- **CRITICAL ENCODING REQUIREMENTS:**
  - All file operations must use explicit encoding parameters: `open(file, 'r', encoding='utf-8')` or `open(file, 'w', encoding='utf-8')`
  - When reading existing files that might have encoding issues, implement defensive reading with fallback encodings (utf-8, latin-1, cp1252)
  - Use `encoding='utf-8', errors='replace'` when encoding errors are expected
  - All string literals and print statements must use only ASCII characters (0-127)
  - **IMPORTANT**: If any imported functions return Unicode characters (like progress bars with █, ▓, or other symbols), wrap those function calls in try/except blocks to catch UnicodeEncodeError and provide ASCII-only fallback output
  - Create ASCII alternatives using characters like #, -, =, +, |, [, ] for any visual elements (progress bars, borders, etc.)
  - Test that ALL output can be safely printed without encoding errors by using only characters in the ASCII range (32-126 for printable characters)
  - If the component handles file I/O, demonstrate both successful and error-handling scenarios for encoding issues
- **EXECUTION INSTRUCTIONS**: Include a comment block at the top of the example explaining how to run it:
  ```python
  # To run this example:
  # From project root: python examples/module_example.py
  # Note: sys.path manipulation in this script ensures imports work from project root
  ```
- The script must be executable, using an `if __name__ == "__main__":` block to call the main demonstration function. 
