# Module: edit_file_tool/instruction_parser.py

## Role and Responsibilities
This module serves as the intelligent translation layer between a user's natural language instructions and the structured commands required by the `text_editor_20250124` tool. Its primary responsibility is to parse a free-form text instruction, potentially containing multiple edit requests, and convert it into a precise, machine-readable list of tool calls.

For example, it must transform an instruction like "In `main.py`, change the variable `max_retries` to 5 on line 23 and add a comment '# Entry point' before the main function" into a list of structured command dictionaries:
`[
  {'command': 'str_replace', 'path': 'main.py', 'old_str': 'max_retries = 10', 'new_str': 'max_retries = 5'},
  {'command': 'insert', 'path': 'main.py', 'insert_line': 49, 'new_str': '# Entry point'}
]`
(assuming the main function is on line 50).

This module will use the Claude LLM to perform the complex parsing task, constructing a specific prompt that guides the model to generate the correct tool call JSON.

## Requirements
1.  **Functional Requirements:**
    *   Implement an asynchronous `InstructionParser` class.
    *   The primary method, `parse()`, must accept a natural language instruction string, a file path, and the content of the file to be edited.
    *   It must use the `claude-3-7-sonnet-20250219` model via the `anthropic` Python library to analyze the instruction in the context of the provided file content.
    *   It must be able to parse all supported edit types mentioned in the project README, including text/line replacements, insertions, appends, multi-step edits, and code fixes.
    *   It must correctly interpret positional language for insertions, such as "after line X", "before line Y", and "at line Z", and convert them to the correct 0-indexed `insert_line` parameter.
    *   It must detect and generate a list of multiple, distinct tool calls when a single instruction contains several edit commands.
    *   The output must be a `List[Dict[str, Any]]`, where each dictionary strictly conforms to the input format of the `text_editor_20250124` tool commands.

2.  **Performance Requirements:**
    *   All operations involving LLM calls must be fully asynchronous using `async/await`.
    *   The prompt sent to the LLM should be engineered for efficiency to elicit a structured, correct response in a single API call, minimizing latency and cost.

3.  **Error Handling Requirements:**
    *   Define a custom exception, `InstructionParserError`, for parsing-related failures.
    *   If the LLM response is not valid JSON or does not conform to the expected `List[Dict]` structure, the `parse()` method should raise `InstructionParserError` with a descriptive message.
    *   If an instruction is too ambiguous for the LLM to create a confident tool call, the process should fail gracefully with an appropriate error.

4.  **Documentation Requirements:**
    *   All classes, methods, and functions must include comprehensive Google-style docstrings.
    *   Full type hinting must be used for all function signatures and variables.

## Dependencies
**Standard Library:**
-   `asyncio`
-   `json`
-   `typing` (specifically `List`, `Dict`, `Any`, `Optional`)

**Third-party:**
-   `anthropic`

**Internal:**
-   The output format must be compatible with the `EditTool20250124` class defined in `edit_file_tool/edit_tool.py`. No direct import is needed, but the contract (the structure of the command dictionaries) is a critical dependency.

## Code Examples
% Here are examples of the required implementation patterns and output formats:
<code_examples>
    % Tool Call Format Example (from examples/editor_tool_example.py)
    <tool_call_format_example>
        <include>examples/editor_tool_example.py</include>
    </tool_call_format_example>

    % Claude API Call Example (from examples/claude_api_example.py)
    <claude_api_call_example>
        <include>examples/claude_api_example.py</include>
    </claude_api_call_example>
</code_examples>

## Implementation Instructions
1.  **Class Structure:**
    *   Create a class named `InstructionParser`.
    *   The constructor `__init__(self, client: anthropic.AsyncAnthropic, model: str = "claude-3-7-sonnet-20250219")` should accept an `anthropic` async client and the model name.

2.  **System Prompt Construction:**
    *   Create a private helper method, `_create_system_prompt()`, that generates the system prompt for the LLM.
    *   This prompt must clearly define the task: to act as an expert system that converts natural language into a JSON array of file editing tool calls.
    *   The prompt must provide a detailed definition of the available `text_editor_20250124` commands: `view`, `str_replace`, `insert`, and `create`. For each command, specify its purpose and all possible parameters.
    *   Crucially, the prompt must explain the `insert_line` logic:
        *   `insert_line` is 0-indexed.
        *   To insert *after* 1-indexed line `N`, use `insert_line: N`.
        *   To insert *before* 1-indexed line `N`, use `insert_line: N-1`.
    *   The prompt must explicitly instruct the model to return a valid JSON array `[...]`, even if only one command is generated.
    *   Refer to the Anthropic documentation for tool use for guidance: <web>https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/text-editor-tool</web>
    *   The JSON output must conform to the structure demonstrated in the "Tool Call Format Example" provided in the "Code Examples" section.

3.  **Parsing Method:**
    *   Implement the main public method `async def parse(self, instruction: str, file_path: str, file_content: str) -> List[Dict[str, Any]]`.
    *   This method will construct the user message for the LLM, including the user's `instruction`, the `file_path`, and the `file_content`. Truncate `file_content` if it's excessively large (e.g., > 100KB) to manage token count, but provide enough context for the model.
    *   Invoke the `anthropic` client's `messages.create` method with the system prompt and the user message.
    *   The request should ask the model to generate a JSON object in its response. Do not use the `tools` parameter for this task; instead, extract the JSON from the text content of the model's response.
    *   Refer to the "Claude API Call Example" in the "Code Examples" section for the correct way to make an asynchronous call to the Claude API.
    *   Use a `try...except` block to handle `json.JSONDecodeError` if the model's output is not valid JSON. Raise `InstructionParserError` on failure.
    *   Validate the parsed structure. Ensure it is a list of dictionaries. If not, raise `InstructionParserError`.
    *   Return the validated list of tool call dictionaries.

## Key Functions and Classes
```python
import asyncio
import json
from typing import Any, Dict, List, Optional

import anthropic

class InstructionParserError(Exception):
    """Custom exception for errors during instruction parsing."""
    pass

class InstructionParser:
    """
    Parses natural language instructions into structured tool calls for file editing.
    """

    def __init__(self, client: anthropic.AsyncAnthropic, model: str = "claude-3-7-sonnet-20250219"):
        """
        Initializes the parser with an Anthropic client and model name.
        """
        pass

    async def parse(self, instruction: str, file_path: str, file_content: str) -> List[Dict[str, Any]]:
        """
        Parses a natural language instruction into a list of structured tool calls.

        Args:
            instruction: The natural language instruction from the user.
            file_path: The path to the file to be edited.
            file_content: The content of the file for context.

        Returns:
            A list of dictionaries, where each dictionary represents a tool call.

        Raises:
            InstructionParserError: If the instruction cannot be parsed or the LLM
                                    returns a malformed response.
        """
        pass

    def _create_system_prompt(self) -> str:
        """
        Creates the system prompt to guide the LLM in parsing instructions.
        """
        pass
```

## Deliverables
1.  A complete and production-ready implementation of the `edit_file_tool/instruction_parser.py` module, containing the `InstructionParser` class and its helper methods.