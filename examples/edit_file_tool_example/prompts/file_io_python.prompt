# Module: edit_file_tool/file_io.py

## Role and Responsibilities
Based on the component_info above, this module is responsible for abstracting all file system read and write operations for the `edit-file-tool`. Its primary purpose is to provide a safe, robust, and asynchronous interface for handling files. This centralization is crucial for security, error handling, and maintaining clean, non-blocking I/O throughout the application.

Key responsibilities include:
- Providing an asynchronous function to read the entire content of a file.
- Providing an asynchronous function to write content to a file, overwriting existing content.
- Ensuring all file operations default to UTF-8 encoding.
- Implementing security checks to prevent path traversal vulnerabilities.
- Gracefully handling common file system errors (e.g., `FileNotFoundError`, `PermissionError`).

## Requirements
1.  **Functional Requirements:**
    *   Must provide an `async` function `read_file_async` to read a file's content into a string.
    *   Must provide an `async` function `write_file_async` to write a string to a file.
    *   All file I/O must be non-blocking to work within the project's `asyncio` event loop.
    *   File encoding must default to `utf-8` for both reading and writing.

2.  **Performance Requirements:**
    *   File operations must be performed asynchronously to avoid blocking the main thread, using a library like `aiofiles`.

3.  **Security Requirements:**
    *   All file paths must be validated to prevent directory traversal attacks.
    *   File operations should be restricted to the current working directory and its subdirectories.
    *   Paths should be resolved to their absolute form before any I/O operation to verify they are not pointing to sensitive areas outside the intended scope.

4.  **Error Handling Requirements:**
    *   Functions must handle `FileNotFoundError`, `PermissionError`, and other potential `OSError` exceptions.
    *   Functions must return a tuple indicating success or failure, along with either the result or an error message. For example: `(content: str | None, error: str | None)` for reading, and `(success: bool, error: str | None)` for writing.

5.  **Documentation Requirements:**
    *   All public functions must have comprehensive Google-style docstrings.
    *   All function signatures must include full type hints.

## Dependencies
Standard Library:
- `asyncio`: For the core asynchronous framework.
- `pathlib`: For object-oriented filesystem path manipulation.
- `os`: For path operations like resolving the CWD.

Third-party:
- `aiofiles`: For asynchronous file operations. This will need to be added to the project's dependencies.

Internal:
- None. This is a low-level utility module.

## Implementation Instructions
1.  **File Structure:**
    *   Create a single Python file: `edit_file_tool/file_io.py`.
    *   Import necessary libraries: `asyncio`, `os`, `pathlib`, `aiofiles`, and `typing`.

2.  **`read_file_async` function:**
    *   Define the function signature: `async def read_file_async(file_path: pathlib.Path) -> tuple[str | None, str | None]:`.
    *   Inside a `try...except` block:
        *   First, validate the path to prevent traversal. Resolve the `file_path` to an absolute path and check that it is within the current working directory. If not, return `(None, "Error: Path is outside the allowed directory.")`.
        *   Use `async with aiofiles.open(file_path, mode='r', encoding='utf-8') as f:` to open the file.
        *   Read the content using `await f.read()`.
        *   Return `(content, None)` on success.
    *   Catch exceptions like `FileNotFoundError`, `PermissionError`, and generic `OSError`. For each, return `(None, "Error: descriptive_error_message")`.

3.  **`write_file_async` function:**
    *   Define the function signature: `async def write_file_async(file_path: pathlib.Path, content: str) -> tuple[bool, str | None]:`.
    *   Inside a `try...except` block:
        *   Perform the same path validation as in `read_file_async`.
        *   Ensure the parent directory of `file_path` exists. Use `file_path.parent.mkdir(parents=True, exist_ok=True)`.
        *   Use `async with aiofiles.open(file_path, mode='w', encoding='utf-8') as f:` to open the file for writing.
        *   Write the content using `await f.write(content)`.
        *   Return `(True, None)` on success.
    *   Catch `PermissionError` and generic `OSError`. For each, return `(False, "Error: descriptive_error_message")`.

4.  **Path Validation Logic:**
    *   It is recommended to create a private helper function `_validate_path` for the security check.
    *   This function should take a `pathlib.Path` object.
    *   It should get the absolute, resolved path of the input and the current working directory.
    *   It should then check if the file path is a subpath of the CWD. An exception should be raised or an error returned if the check fails.
    *   Reference for path operations: <web>https://docs.python.org/3/library/pathlib.html</web>
    *   Reference for async file I/O: <web>https://docs.python.org/3/library/io.html</web>
    *   Reference Implementation Example: Here is an example of a utility script that demonstrates security validation and error handling for file operations: <utility_example><include>examples/utils_example.py</include></utility_example>

## Key Functions and Classes
-   `async def read_file_async(file_path: pathlib.Path) -> tuple[str | None, str | None]:`
    *   Asynchronously reads content from a file.
    *   Returns a tuple containing the file content and an error message (if any).
-   `async def write_file_async(file_path: pathlib.Path, content: str) -> tuple[bool, str | None]:`
    *   Asynchronously writes content to a file.
    *   Returns a tuple containing a success flag and an error message (if any).

## Deliverables
1.  Complete implementation of `edit_file_tool/file_io.py` with the functions specified above.
2.  A corresponding test file `tests/test_file_io.py` with comprehensive unit tests covering:
    *   Successful file read and write operations.
    *   Error case: reading a non-existent file.
    *   Error case: writing to a read-only location.
    *   Security case: attempting to read/write a file outside the current working directory (e.g., `../../etc/passwd`).
    *   Correct handling of unicode characters to verify UTF-8 encoding.
3.  Full type hints for all functions and classes as per PEP 484.
4.  Google-style docstrings for all public functions.
5.  Robust error handling for all identified edge cases, returning user-friendly error messages.