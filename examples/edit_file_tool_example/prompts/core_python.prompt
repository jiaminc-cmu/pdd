You are an expert Software Engineer. Your goal is to extract the updated prompt from the LLM output.

Here is the generated llm_output: <llm_output># Module: {placeholder}

## Context
<required_context_files>
  % Architecture defines role, ownership, and dependency ordering.
  <architecture>
    <include>pdd/architecture.json</include>
  </architecture>

  % Owned API layer (single source of truth for Anthropic client, tools, retries, costs, cache headers).
  <claude_api>
    <include>edit_file_tool/claude_api.py</include>
  </claude_api>

  % File editor tool (owns file I/O semantics and safety for view/insert/replace/create/undo).
  <editor_tool>
    <include>edit_file_tool/editor_tool.py</include>
  </editor_tool>

  % Think tool definition and behavior.
  <think_tool>
    <include>edit_file_tool/think_tool.py</include>
  </think_tool>

  % Shared utilities (logging, validation, cache decisions, cost formatting, config).
  <utils>
    <include>edit_file_tool/utils.py</include>
  </utils>

  % Instruction parser (converts NL instructions into structured edit commands).
  <instruction_parser>
    <include>edit_file_tool/instruction_parser.py</include>
  </instruction_parser>

  % Cache manager (policy and decisioning for prompt caching and reporting).
  <cache_manager>
    <include>edit_file_tool/cache_manager.py</include>
  </cache_manager>

  % The README grounds UX, CLI, caching, and cost-tracking requirements.
  <readme>
    <include>EDIT_FILE_TOOL_README.md</include>
  </readme>
</required_context_files>

## Role and Responsibilities
[Analyze <component_info> for {placeholder} from the architecture. Define the module's purpose and exact role in the system.
Key points to state succinctly:
- What is the core functionality of this module?
- Which responsibilities it owns vs. delegates.
- Which <readme> requirements it implements directly (and which are handled by other modules).]

## Component Selection
[From the <architecture> JSON, select the single object whose `path` or `filename` matches `{placeholder}`. Treat its `reason` and `description` as the authoritative <component_info> for this module.]

## Dependencies
[Based on the hierarchical dependency rule, list only necessary imports. A component can import modules that appear before it in the architecture.]

### Standard Library
[List relevant standard library imports. Based on the component's description, this will likely include `asyncio`, `pathlib`, `os`, `sys`, `json`, `logging`, and `typing` (e.g., `Dict`, `List`, `Tuple`, `Optional`, `Callable`, `Literal`).]

### Third-party
[List external dependencies.
- Only `edit_file_tool/claude_api.py` owns the `anthropic` SDK and tool registration. Other modules must not import `anthropic` and must call into `claude_api` instead.
- If it's a CLI component, import `click` or `argparse`.
- If it's a test component, import `pytest` and `unittest.mock`.]

### Internal
[From the architecture and description:
- Import only modules that appear before {placeholder} and are actually used.
- Respect ownership: file operations in `editor_tool`; API calls, tool registration, retries, cache headers, and cost math in `claude_api`; think tool in `think_tool`.
- Do not reference non-existent modules or add unused imports.]

## Requirements
[Define concise, targeted requirements for this module, tailored to its classification.]

### Functional Requirements
1.  [List the specific functions/classes this module must implement per <component_info>. Keep names and signatures explicit.]
2.  **Ownership and Delegation:**
    -  Only `edit_file_tool/claude_api.py` initializes `anthropic.AsyncAnthropic`, registers tools, applies cache headers, implements retries/backoff, and computes cost. Other modules must call `claude_api.call_claude_api(...)` and must not redefine tools or import `anthropic`.
    -  File operations (`view`, `str_replace`, `insert`, `create`, `undo_edit`) live in `editor_tool` (async, safe, deterministic). Call these via adapters as needed.
    -  The think tool definition/behavior lives in `think_tool`.
3.  **File Operation Semantics (when applicable):**
    -  Directory listings: sorted lexicographically; format `Contents of directory '{path_str}':\n` + entries joined by `\n`.
    -  File view: number lines from 1; for `view_range=(start,end)`, enforce 1 ≤ start ≤ end ≤ total; on invalid ranges include `Invalid view_range` and the file's line count.
    -  Insert: `insert_line` is 0-indexed; 0 inserts at beginning; N>0 inserts after line N; if `insert_line > len(lines)`, error: `Invalid insert_line {N}. File only has {len} lines.`
    -  Replace: enforce exactly one occurrence; on 0 matches include `not found`; on multiple include `Found {count} occurrences of '{old_str}'`.
4.  **CLI (if applicable):** Implement `--verbose`, `--model`, `--cache` per <readme> with `click` or `argparse`.
5.  **Caching:** Make cache decisions (e.g., `auto`/`always`/`never`) via `utils.should_use_cache(...)` or `cache_manager`. Do not set `cache_control` in callers; `claude_api` handles headers. Separate static file content from dynamic instructions for cache effectiveness.
6.  **Cost Tracking:** Use the `cost_info` returned by `claude_api.call_claude_api` and aggregate across iterations. Do not recompute costs outside `claude_api`. Surface totals with consistent currency formatting (USD, 4 decimals) via `utils.format_cost`.
7.  **Return Contracts:** Public APIs must match downstream expectations. For `edit_file_tool/core.py`, expose `async def edit_file(...) -> Tuple[bool, Optional[str], float]` where the float is the aggregate LLM cost ≥ 0.0.
8.  **Tool-Call Handling and Shaping (core orchestrator):**
    -  Normalize tool_use blocks to plain values: obtain `type`, `name`, `id`, `input` via dict-or-attribute access and cast `name` to `str` before comparisons.
    -  Do not hardcode tool names. Determine routing dynamically from included modules and/or the response:
       - Resolve the think tool name from `think_tool.ThinkTool.get_definition()["name"]` or from the actual tool name provided by `claude_api`.
       - Resolve editor tool identifiers from `claude_api` (e.g., values in `MODEL_TO_TEXT_EDITOR_TOOL`). Route to the editor when the tool_use `name` matches any registered editor tool name.
       - If no registered tool matches the `name`, produce an unknown-tool error that lists valid tools for the current turn based on the tools registered by `claude_api`.
    -  Support both sync and async editor calls: if the editor invocation returns an awaitable, `await` it; otherwise, accept the sync result.
    -  Tool result shape must be:
       - `{ "type": "tool_result", "tool_use_id": <id>, "content": [{ "type": "text", "text": <message>, "is_error": <bool> }], "is_error": <bool> }`.
       - Duplicate the `is_error` flag at both top-level and inside the first text block.
    -  On editor failure (`success=False`) or exceptions, return a tool_result with `is_error=True` and the error text. Do not abort the conversation loop; let the model recover.
    -  After collecting tool_results for a turn, append them as a single user message: `{ "role": "user", "content": [ ...tool_result blocks... ] }`.

### Configuration
1.  Do not hardcode model IDs, cache modes, or timeouts. Accept via parameters and/or env (e.g., `EDIT_FILE_TOOL_MODEL`, `EDIT_FILE_TOOL_CACHE_MODE`, `EDIT_FILE_TOOL_TIMEOUT_MS`).
2.  Tool configuration is owned by `claude_api`; callers must not specify tools unless they are the API module itself.
3.  Import only what you use, respecting architecture order. Prefer dependency injection/factories for obtaining instances instead of hardcoding concrete class names.

### Performance and Efficiency
1.  All I/O-bound operations are `async`. Use `asyncio.gather` when helpful.
2.  Token efficiency: let `claude_api` register the think tool; do not duplicate.
3.  Caching: separate static file content from instructions; only `claude_api` applies cache headers and computes cache-aware costs.
4.  Timeouts/cancellation: apply explicit timeouts at appropriate layers; avoid blocking.

### Error Handling and Resilience
1.  Handle errors robustly for API, file I/O, and validation.
2.  Retries/backoff for Anthropic errors live in `claude_api`; callers should not duplicate SDK-level retries.
3.  Validate inputs (paths, instructions) and provide clear errors.

### Security
1.  Handle `ANTHROPIC_API_KEY` via env; never hardcode.
2.  Path validation and file safety live in `editor_tool`/`file_io`. Do not bypass them.
3.  Enforce text file limits and UTF-8 handling where applicable.

### Documentation
1.  Provide concise Google-style docstrings for modules/classes/functions.
2.  Use full type hints on public APIs.
3.  Production modules must not contain tests; place tests under `tests/`.

## Code Examples
% Here are examples of how to use internal modules:
<internal_example_modules>
    % Example of how to call the Claude API, handle costs, and use caching via the claude_api module.
    <claude_api_example>
        <include>examples/claude_api_example.py</include>
    </claude_api_example>

    % Example of how to use the editor tool for safe file operations like view, insert, replace, and undo.
    <editor_tool_example>
        <include>examples/editor_tool_example.py</include>
    </editor_tool_example>

    % Example of how the think tool is defined and handled in the conversation loop.
    <think_tool_example>
        <include>examples/think_tool_example.py</include>
    </think_tool_example>

    % Example of how to use shared utilities for logging, cost formatting, path validation, and cache decisions.
    <utils_example>
        <include>examples/utils_example.py</include>
    </utils_example>
</internal_example_modules>

## Implementation Instructions
[Provide a clear, minimal algorithm tailored to the module.]

1.  **Structure:** Define only the classes/functions this module owns per <component_info>.
2.  **Initialization:**
    - API client setup exists only in `claude_api`.
    - File tool state (e.g., backups) in `editor_tool`.
3.  **Core Logic:**
    - **API Interaction:** Call `edit_file_tool.claude_api.call_claude_api(messages=..., model=..., use_cache=..., system_prompt=..., ...)`. Do not pass a tools list unless implementing `claude_api` itself.
    - **File Editing:** When applicable, route commands to the editor tool, enforcing the semantics above. Support both async and sync editor invocations (await if awaitable, else use value).
    - **Tool Wiring:** Normalize tool_use blocks (dict-or-attr access; cast `name` to `str`), route exactly as specified, and always produce the exact tool_result shape with duplicated `is_error` (top-level and inner text block). On unknown commands, return an error tool_result that lists valid tools.
    - **Main Orchestrator (core.py):** Implement `edit_file(...)` that builds messages, chooses `use_cache` via `utils.should_use_cache(...)` or `cache_manager`, calls `claude_api`, handles tool_use loops up to `max_iterations`, aggregates `cost_info['total_cost']`, and appends tool_results as a single user message per turn.
4.  **Integration:**
    - Upstream: import/call only earlier modules.
    - Downstream: expose clear public APIs with exact return contracts.
5.  **Error Handling:** Catch specific exceptions; return informative errors.
6.  **Logging:** Use `utils.get_logger(__name__)`. Surface cost totals and cache status concisely.

## Key Functions and Classes
[List the main functions/classes to implement with explicit signatures.]
Examples:
- For `edit_file_tool/core.py`:
  - `async def edit_file(file_path: str, edit_instructions: str, model: str, ...) -> Tuple[bool, Optional[str], float]`.
  - `async def handle_tool_call(tool_name: str, arguments: dict, editor: Optional[object] = None) -> dict`.
- For `edit_file_tool/claude_api.py`:
  - `async def call_claude_api(messages: List[Dict[str, Any]], model: ModelName, system_prompt: Optional[str], use_cache: bool, max_tokens: int, temperature: float) -> Tuple[Message, CostInfo]`.

Additional utility:
- `async def handle_tool_call(tool_name: str, arguments: dict, editor: Optional[object] = None) -> dict`: Adapter that validates arguments and delegates to the provided editor instance (or a factory-resolved one), without hardcoding the editor class name.

## Deliverables
1.  A complete, production-ready Python module `{placeholder}` consistent with ownership rules and architecture.
2.  Strict adherence to configuration via params/env (no hardcoded IDs), and dependency ordering.
3.  Concise Google-style docstrings and full typing for public APIs.
4.  Robust error handling for all potential failure points.

## Prohibited Behaviors
- Do not import `anthropic` outside `edit_file_tool/claude_api.py`.
- Do not define or inject tool schemas (text editor or think) outside `edit_file_tool/claude_api.py` and `think_tool.py`.
- Do not embed unit tests inside production modules; place them under `tests/`.