# Module: edit_file_tool/cli.py

## Context
<required_context_files>
  % Architecture defines role, ownership, and dependency ordering.
  <architecture>
    <include>pdd/architecture.json</include>
  </architecture>

  % Core orchestrator (async edit_file) that the CLI must delegate to.
  <core>
    <include>edit_file_tool/core.py</include>
  </core>

  % API layer (source of DEFAULT_MODEL and API integration). CLI must not call it directly; only core does.
  <claude_api>
    <include>edit_file_tool/claude_api.py</include>
  </claude_api>

  % Shared utilities (logging, formatting, configuration helpers).
  <utils>
    <include>edit_file_tool/utils.py</include>
  </utils>

  % README grounds UX and options used by the CLI.
  <readme>
    <include>EDIT_FILE_TOOL_README.md</include>
  </readme>
</required_context_files>

## Role and Responsibilities
This module serves as the primary command-line interface (CLI) for the `edit-file-tool` package. Its responsibility is to provide a user-friendly way to interact with the tool from the terminal: parse arguments and options, validate environment requirements, invoke the core async editing logic, and present results (including LLM cost) to the user. It must not duplicate core or API logic and must respect module ownership defined in the architecture.

Key responsibilities include:
- Defining the `edit-file` command structure using the `click` library.
- Parsing two required positional arguments: `file_path` and `edit_instructions`.
- Handling options: `--verbose`, `--model`, and `--cache`.
- Validating the presence of the `ANTHROPIC_API_KEY` environment variable before importing core to avoid premature import-time failures.
- Delegating to `edit_file_tool.core.edit_file` only after env validation.
- Managing the `asyncio` event loop (synchronously wrap the async CLI function).
- Reporting success/failure and the final LLM cost.
- Providing clear, automatically generated help messages.

## Requirements
1.  **Functional:**
    - Define a command named `edit-file` using `click`.
    - Required arguments: `file_path` and `edit_instructions`.
    - Options: `--verbose` (flag), `--model` (string), `--cache` (choice of `auto|always|never`, default `auto`).
    - Check for `ANTHROPIC_API_KEY` before importing `edit_file_tool.core`. If not set, print an informative error to stderr and exit non-zero.
    - Delegate to `core.edit_file(...)` and print a success/failure message and the cost (formatted to 4 decimals).
    - Avoid direct calls to the Claude API; only core interacts with it per architecture.

2.  **Performance:**
    - Keep startup lightweight. Use `asyncio.run()` to run the async CLI function from a synchronous entry point.

3.  **Security:**
    - Read `ANTHROPIC_API_KEY` from env; never hardcode.
    - Do minimal path validation via Click if desired, but do not duplicate security checks enforced by `file_io`.

4.  **Error Handling:**
    - On any failure, print a clear message to stderr and exit with status code 1; exit 0 on success.
    - Prefer `click.ClickException` or `click.echo(..., err=True)` for errors.

5.  **Documentation:**
    - Provide concise docstrings and full type hints for public functions.

## Dependencies
Standard Library:
- `asyncio` (run the async function)
- `os` (read env)
- `sys` (exit codes)
- `typing` (type hints)

Third-party:
- `click` (CLI)

Internal:
- `edit_file_tool/core.py` (async `edit_file` function)
- `edit_file_tool/claude_api.py` (import `DEFAULT_MODEL` after env validation)

## Implementation Instructions
1.  **Setup Click Command:**
    - Define a synchronous Click command `cli` with `@click.command()`.
    - Use `@click.argument()` for `file_path` and `edit_instructions`.
    - Use `@click.option()` for `--verbose` (`-v`, `is_flag=True`).
    - Use `@click.option()` for `--model` (`-m`, string). Default resolution: if `--model` not provided, prefer `os.getenv('EDIT_FILE_TOOL_MODEL')`, otherwise import `DEFAULT_MODEL` from `edit_file_tool.claude_api` after env validation.
    - Use `@click.option()` for `--cache` (`-c`, `click.Choice(['auto','always','never'], case_sensitive=False)`, default `'auto'`). Map to `'auto' | True | False` for `core.edit_file`.

2.  **API Key and Import Order:**
    - At the beginning of `cli`, check `os.getenv('ANTHROPIC_API_KEY')`.
    - If missing, print an informative error to stderr and exit(1).
    - Only after passing this check, import `edit_file_tool.core` and (if needed) `DEFAULT_MODEL`/`SUPPORTED_MODELS` from `edit_file_tool.claude_api`.
    - If importing `core` fails (e.g., ImportError), print an error to stderr and exit(1).

3.  **Model Resolution and Validation:**
    - Resolve model precedence: CLI `--model` option > `os.getenv('EDIT_FILE_TOOL_MODEL')` > `claude_api.DEFAULT_MODEL`.
    - Validate the resolved model is in `claude_api.SUPPORTED_MODELS`. On mismatch, print an error and exit(1).

4.  **Invoke Core and Handle Output:**
    - Call `asyncio.run(core.edit_file(file_path=file_path, edit_instructions=edit_instructions, model=model, use_cache=mapped_cache, verbose=verbose))` inside the sync `cli`.
    - Unpack `(success, error, llm_cost)` and print cost as `LLM cost: $<cost: .4f>` when > 0. On failure, print error to stderr and exit(1); else exit(0).

    % Here is an example of how to call the core `edit_file` function, which the CLI is responsible for delegating to.
    <core_function_example>
      <include>examples/core_example.py</include>
    </core_function_example>

5.  **Sync Entry Point wrapping asyncio:**
    - Provide a synchronous `main()` that wraps an `asyncio.run(...)` call to satisfy runtime and tests. Implement a tiny async wrapper that invokes the Click command synchronously, e.g., `async def _wrapped(): return cli.main(standalone_mode=False)`, then `asyncio.run(_wrapped())`.
    - Catch all exceptions in `main()`, print to stderr, and `sys.exit(1)`.

## Key Functions and Classes
- `async def cli(file_path: str, edit_instructions: str, model: str, verbose: bool, cache: str) -> None:`
  The main asynchronous function decorated with Click. It validates env, resolves defaults, imports core, calls `edit_file`, and prints results.

- `def main() -> None:`
  The synchronous entry point that runs the async CLI with `asyncio.run(cli())`.

## Deliverables
1.  A complete and functional `edit_file_tool/cli.py` that meets the requirements and respects module ownership.
2.  Full type hints and concise docstrings for public functions.
3.  Robust error handling for missing API keys, invalid arguments, and errors returned from `core.edit_file`.