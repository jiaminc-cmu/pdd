You are an expert Python developer. Create a command-line script in a single Python file that automates a PDD (Prompt-Driven Development) workflow.

The script should be an executable file, so include the `#!/usr/bin/env python3` shebang.

**Overall Script Purpose:**
The script's main purpose is to take a component name, run the `pdd sync` command with specific options, log the command that was run, and clean up temporary files generated during the process.

**Global Configuration:**
At the top of the script, define the following global configuration variables with comments explaining their purpose:
- `EXECUTION_MODE = 'execute'`
- `ENABLE_LOGGING = False`
- `ENABLE_COST_TRACKING = False`
- `USE_INFISICAL = False`
- `ENABLE_TAGGING`: This should be a boolean derived from the `ENABLE_TAGGING` environment variable, defaulting to 'no'.

**Core Functions:**

1.  **`ensure_init_file()`:**
    - This function ensures that the directory `edit_file_tool` exists and contains an `__init__.py` file.
    - If the directory doesn't exist, create it.
    - If `__init__.py` doesn't exist, create it and write the string `"""Edit File Tool Package"""\n` into it.
    - Print an `[INFO]` message upon creation.

2.  **`create_cmd_file(component_name: str, cmd_executed: list, exit_code: int, log_file: str = None)`:**
    - This function creates a command log file.
    - The file path should be `make_creation/{component_name}/cmd_{component_name}.txt`. Ensure the directory exists.
    - The file should contain the following content, including the comments:
        ```
        # Component: {component_name}
        # Commands are intended to be run from the project root.
        # PHASE 0: Clean existing files enabled - deleted existing component files
        # Using prompt file: 'prompts/{component_name}_python.prompt'
        
        # PHASE 1: PDD Sync - Complete Workflow
        # Uses the pdd sync command to automatically execute the complete PDD workflow.
        # This includes auto-deps, generate, example, crash, verify, test, fix, and update phases.
        {command_string}
        ```
    - The `{command_string}` should be generated by joining the `cmd_executed` list with spaces. If `log_file` is provided, append ` > "{log_file}" 2>&1` to the string.

3.  **`cleanup_component_files(base_name: str)`:**
    - This function cleans up temporary and versioned files for a given component.
    - It should target the following directories and files:
        - `edit_file_tool`: Delete all files starting with `{base_name}` and ending in `.py`, EXCEPT for `{base_name}.py`.
        - `examples`: Delete all files starting with `{base_name}` and ending in `.py`, EXCEPT for `{base_name}_example.py`.
        - `tests`: Delete all files starting with `test_{base_name}` and ending in `.py`, EXCEPT for `test_{base_name}.py`.
        - `.pdd/meta`: Delete ALL files starting with `{base_name}_python`.
    - Print informative `[INFO]`, `[SUCCESS]`, and `[WARN]` messages throughout the cleanup process.

4.  **`run_pdd_sync(component_name: str, log_file: str = None, enable_cost_tracking: bool = False) -> int`:**
    - This function executes the `pdd sync` command using `subprocess.run`.
    - The base command is `pdd --local --force`. If `USE_INFISICAL` is true, prepend it with `infisical run --`.
    - If `enable_cost_tracking` is true, add the `--output-cost` flag, saving the report to `make_creation/{component_name}/cost_{component_name}.csv`.
    - Append `sync` and the `component_name` to the command.
    - The command should be passed to `subprocess.run` as a list of strings.
    - If a `log_file` is provided, redirect both stdout and stderr to it.
    - Handle `FileNotFoundError` if `pdd` is not found.
    - Return the exit code of the subprocess.

**Main Workflow (`main()` function):**

1.  **Argument Parsing:** Use `argparse` to set up the command-line interface.
    - A required positional argument: `component_name`.
    - `--clean` or `--override`: An optional flag.
    - `--no-cleanup`: An optional flag to skip the cleanup step.
    - `--print-only`: An optional flag to print commands without executing them.
    - `--no-log`: An optional flag to disable logging.
    - `--enable-cost-tracking`: An optional flag to enable cost tracking.

2.  **Execution Logic:**
    - Get the `base_name` by removing `.py` from the `component_name` if present.
    - Check if the prompt file `prompts/{base_name}_python.prompt` exists. If not, exit with an error.
    - Call `ensure_init_file()`.
    - If logging is enabled, define the log file path as `logs/{base_name}_sync.txt`.
    - **Handle `--print-only` mode:** If this flag is present, print the command that would be run and a summary of other actions (logging, cost tracking, cleanup) and then exit. Do not execute anything.
    - **Execute the workflow:**
        - Call `run_pdd_sync()` to execute the command and get the exit code.
        - After execution, call `create_cmd_file()`. **Crucially**, when preparing the command list for this function, create a *display version* where the component name and cost file path are enclosed in double quotes (e.g., `"component_name"`, `"path/to/cost.csv"`) for better readability in the output file.
        - Print `[SUCCESS]` or `[ERROR]` messages based on the exit code from the sync command.
        - If `--no-cleanup` was NOT specified, call `cleanup_component_files()`.
        - If the sync command failed (non-zero exit code), the script should exit with that same code.

Finally, use the standard `if __name__ == "__main__":` block to call the `main()` function. Ensure all functions have docstrings and type hints.