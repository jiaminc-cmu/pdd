You are an expert Python developer. Create a Python script that automates a prompt generation workflow.

The script's main purpose is to read a list of source code filenames from a JSON file, create intermediate "template prompts" for each, and then use a command-line tool called `pdd` to generate the final prompts.

**Detailed Requirements:**

**1. Configuration:**
- At the top of the script, define global constants for all necessary file and directory paths. Use `os.path.join` for directory paths to ensure cross-platform compatibility.
    - `ARCHITECTURE_JSON`: "pdd/architecture.json"
    - `SOURCE_PROMPT_TEMPLATE`: "prompts/script_prompts/modify_template_prompt.prompt"
    - `TEMPLATE_PROMPTS_DIR`: "prompts/template_prompts"
    - `FINAL_PROMPTS_DIR`: "prompts"
    - `LOG_DIR`: "logs/scripts_prompts"
    - `COST_REPORT_DIR`: "cost_reports"
    - `COST_REPORT_FILE`: "cost_reports/prompt_cost.csv"

**2. `pdd` Command Helper Function:**
- Create a function `get_pdd_command_prefix()` that builds the command prefix for the `pdd` tool.
- This function should first check for an environment variable `PDD_CMD`. If it's set, return its value.
- As a fallback, it should check for `USE_INFISICAL` and `USE_LOCAL` environment variables (defaulting to 'yes' for both).
- Based on these variables, construct the command string. For example, if `USE_INFISICAL` is 'yes', the command should be prefixed with `infisical run --`. If `USE_LOCAL` is 'yes', the `--local` flag should be added to the `pdd` command.

**3. Shell Command Executor Function:**
- Implement a robust function `run_shell_command(command: str)` that executes a given shell command string.
- It must be cross-platform:
    - On **Windows**, it should use `pwsh` if available, otherwise `powershell`.
    - On **Unix-like systems** (Linux, macOS), it should use `/bin/bash`.
- The function must capture and print `stdout` and `stderr` from the executed command.
- It should return the command's exit code (0 for success, non-zero for failure).
- Use `subprocess.run` and include comprehensive error handling for `subprocess.CalledProcessError`.

**4. Main Workflow (`main` function):**
- **Prerequisite Checks:**
    - Verify that `ARCHITECTURE_JSON` and `SOURCE_PROMPT_TEMPLATE` exist. If either is missing, print an error and exit the script.
- **Setup:**
    - Create all required output directories (`TEMPLATE_PROMPTS_DIR`, `FINAL_PROMPTS_DIR`, `LOG_DIR`, `COST_REPORT_DIR`) using `os.makedirs(..., exist_ok=True)`.
- **Data Loading:**
    - Read and parse the `ARCHITECTURE_JSON` file. It contains a JSON list of objects, where each object has a `"filename"` key (e.g., `[{"filename": "script1.py"}]`).
    - Read the content of the `SOURCE_PROMPT_TEMPLATE` file into a string variable.
- **Processing Loop (Two Phases):**
    - Create an empty list to hold all the shell commands to be executed.
    - Loop through each item in the list loaded from `ARCHITECTURE_JSON`.
    - **Phase 1: Prepare Template Prompts:**
        - For each filename, determine the path for an intermediate "template prompt" (e.g., for `script1.py`, the path would be `prompts/template_prompts/script1_python_prompt.prompt`).
        - If this template prompt file does **not** already exist, create it by replacing the exact string `"placeholder.py"` in the source template content with the current filename. Then, write this new content to the file.
        - If the file already exists, print an informational message and skip creation.
    - **Phase 2: Construct Generation Commands:**
        - In the same loop, construct the full shell command to generate the final prompt. The command must follow this pattern:
          `{PDD_PREFIX} --output-cost "{COST_FILE}" generate --output "{FINAL_PROMPT_PATH}" "{TEMPLATE_PROMPT_PATH}" > "{LOG_FILE}" 2>&1`
        - Ensure all file paths used within the command string are formatted with forward slashes (`/`) for cross-platform compatibility.
        - Append the fully constructed command string to the list of commands.
- **Execution:**
    - After the loop is complete, iterate through the list of generated commands.
    - Execute each command using your `run_shell_command` function.
    - If a command fails (returns a non-zero exit code), print a `[WARN]` message but **continue** execution with the next command.

**5. Script Structure and Logging:**
- Use clear, prefixed print statements (e.g., `[INFO]`, `[ERROR]`, `[SUCCESS]`, `[WARN]`, `[STDOUT]`, `[STDERR]`) to provide detailed feedback on the script's execution.
- Use a standard `if __name__ == "__main__":` block to call the `main` function.