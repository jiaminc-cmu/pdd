% You are an expert Python developer and code generation specialist. Your goal is to write a prompt that will generate the implementation code for the {placeholder} module. The prompt you create will be used to produce a detailed implementation specification.

% Input Requirements:
% 1. Project Documentation: <readme><include>EDIT_FILE_TOOL_README.md</include></readme>
% 2. Project Structure: <project_structure><include>examples\edit_file_tool_example\pdd\architecture.json</include></project_structure>
% 3. Component Architecture: <component_info><shell>python -c "</shell></component_info>

import json
import sys

# Load tool.json and find the component matching {placeholder}
with open('tool.json', 'r') as f:
    components = json.load(f)

target_path = '{placeholder}'
target_filename = target_path.split('/')[-1] if '/' in target_path else target_path

# Find the matching component
for component in components:
    if component['path'] == target_path or component['filename'] == target_filename:
        print(f'Path: {component[\"path\"]}')
        print(f'Filename: {component[\"filename\"]}')
        print(f'Reason: {component[\"reason\"]}')
        print(f'Description: {component[\"description\"]}')
        break
else:
    print('Component not found in tool.json')
    sys.exit(1)
"</shell></component_info>
% 3. Related Components: <related_components><shell>python -c "
import json

# Load tool.json and find components that depend on or are dependencies of {placeholder}
with open('tool.json', 'r') as f:
    components = json.load(f)

target_path = '{placeholder}'
target_filename = target_path.split('/')[-1] if '/' in target_path else target_path

# Find dependencies mentioned in descriptions
target_component = None
for component in components:
    if component['path'] == target_path or component['filename'] == target_filename:
        target_component = component
        break

if target_component:
    print('Dependencies mentioned in description:')
    description = target_component['description']
    for comp in components:
        module_name = comp['path'].replace('/', '.').replace('.py', '')
        if module_name in description and comp['path'] != target_path:
            print(f'- {comp[\"path\"]}: {comp[\"reason\"]}')
"</shell></related_components>

% Your task is to create a comprehensive prompt for the {placeholder} module that will:
% 1. Clearly define the module's purpose and responsibilities
% 2. Specify all requirements and constraints
% 3. List all necessary dependencies
% 4. Provide detailed implementation instructions
% 5. Define clear deliverables and success criteria

% Follow this structure for your prompt:

% <prompt>
% # Module: {placeholder}
% 
% ## Role and Responsibilities
% [Based on the component_info above, describe the module's purpose, its role in the edit-file-tool system, and key responsibilities]
% 
% ## Requirements
% 1. [Functional requirements based on the component description]
% 2. [Performance requirements for async operations where applicable]
% 3. [Security requirements for API key handling, file operations, etc.]
% 4. [Error handling requirements specific to this component]
% 5. [Documentation requirements with proper docstrings and type hints]
% 
% ## Dependencies
% [List the dependencies mentioned in the related_components section above]
% Standard Library:
% - [List relevant standard library imports like asyncio, pathlib, etc.]
% 
% Third-party:
% - [List external dependencies like anthropic SDK, etc.]
% 
% Internal:
% - [List internal edit_file_tool module dependencies]
% 
% ## Implementation Instructions
% 1. [Step-by-step implementation guide based on the component description]
% 2. [Code structure and organization following the described functionality]
% 3. [Async/await patterns where the component description mentions async operations]
% 4. [Error handling approach for the specific component type]
% 5. [Integration points with other components as described in the tool.json]
% 
% ## Key Functions and Classes
% [Based on the component description, list the main functions, classes, and methods that need to be implemented]
% 
% ## Deliverables
% 1. [Complete implementation of {placeholder}]
% 2. [Unit tests with comprehensive coverage]
% 3. [Type hints for all functions and classes]
% 4. [Docstrings following Google or NumPy style]
% 5. [Error handling for all identified edge cases]
% </prompt>

% Important Notes:
% - Follow the exact functionality described in the component description from tool.json
% - Ensure all dependencies listed in the component description are properly handled
% - Include comprehensive error handling and validation
% - Follow Python best practices and PEP 8 style guidelines
% - Include type hints and docstrings for all functions and classes
% - Consider async/await patterns where mentioned in the component description
% - Implement proper logging where appropriate
% - Ensure the generated code integrates properly with the edit-file-tool architecture
% - Handle edge cases and error conditions gracefully
% - Make the code production-ready and well-tested