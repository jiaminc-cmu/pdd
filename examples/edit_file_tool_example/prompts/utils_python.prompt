# Module: edit_file_tool/utils.py

## Role and Responsibilities
This module serves as the foundational utility layer for the edit-file tool, offering shared functionality such as structured logging, exception formatting, type-safe helpers, cost calculation, and caching logic. It ensures consistent behavior and error reporting across the codebase, reducing duplication and improving maintainability.

As the first module to be implemented (priority 1), it has no dependencies and provides the foundation that all other components depend on for logging, error propagation, type annotations, and common utilities.

Key responsibilities include:
1.  **Logging Infrastructure**: Providing a configurable async-safe logger with structured output, performance timing, and consistent formatting across all modules.
2.  **Exception Handling**: Defining custom exception classes for tool-specific errors and providing utilities for error formatting and propagation.
3.  **Type Safety**: Defining common type aliases, constants, and type-safe helper functions used throughout the system.
4.  **Cost Management**: Providing up-to-date pricing information for all supported Anthropic models and calculating the precise cost of API interactions, including complex scenarios involving prompt caching.
5.  **Cache Strategy**: Implementing the "smart cache management" logic to automatically determine if prompt caching is beneficial for a given file, based on its size and complexity.
6.  **Performance Utilities**: Providing decorators for retry logic, performance timing, and async operation management.
7.  **Validation Helpers**: Offering utilities for validating file paths, checking model compatibility, and formatting metrics.
8.  **System Integration**: Supporting future enhancements like structured logging, telemetry integration, and diagnostics.

## Requirements
1.  **Functional Requirements:**
    *   **Logging Infrastructure**: Must provide a configurable async-safe logger with structured output, different log levels, and consistent formatting. Should support both console and file output with rotation capabilities.
    *   **Exception Handling**: Must define custom exception classes for different error types (EditToolError, FileOperationError, APIError, ValidationError) with proper inheritance and error context preservation.
    *   **Type System**: Must define comprehensive type aliases for common patterns (FilePath, ModelName, CacheMode, EditInstruction) and provide type-safe helper functions.
    *   **Model Pricing**: Must maintain a comprehensive and easily updatable dictionary of token prices for all supported Anthropic models that support text editor tools (Claude 4 Opus & Sonnet with text_editor_20250728, defaulting to Claude Sonnet 3.7 with text_editor_20250124, Claude Sonnet 3.5 with text_editor_20241022).
    *   **Cache Pricing**: The pricing data must include distinct rates for standard input/output, cached input reads (90% discount), and cached input writes (25% premium), as described in the project README.
    *   **Cost Calculation**: The cost calculation function must accurately compute the total cost in USD based on the model, token counts, and the caching status (no cache, cache write, or cache read).
    *   **Cache Auto-Detection**: The `should_use_cache` function must correctly implement the smart cache management rules:
        *   **Disabled**: For files smaller than 1KB.
        *   **Enabled**: For files larger than 4KB.
        *   **Complexity-based**: For files between 1KB and 4KB, the decision must be based on line count and content density.
    *   **Performance Decorators**: Must provide decorators for retry logic with exponential backoff, performance timing measurement, and async operation management.
    *   **Validation Utilities**: Must provide functions for validating file paths, checking model compatibility with tool features (e.g., text_editor_20250124 support), and formatting cost/performance metrics.
    *   **Constants Management**: Must define system-wide constants for supported models, default configurations, file size thresholds, and error messages.
2.  **Performance Requirements:**
    *   All functions in this module must be highly performant and have minimal overhead, as they will be called within the main application loop.
    *   The module must not perform any file I/O or network operations itself; it should operate on data passed to it.
    *   Logging operations must be async-safe and non-blocking to avoid performance bottlenecks.
    *   Decorators must add minimal overhead and support both sync and async functions.
3.  **Security Requirements:**
    *   Logging functions must sanitize sensitive information (API keys, file contents) before output.
    *   Path validation must prevent directory traversal attacks and access to restricted system files.
    *   Error messages must not leak sensitive system information or internal implementation details.
4.  **Error Handling Requirements:**
    *   Functions must handle requests for unknown or unsupported model names gracefully. They should log a warning and fall back to a reasonable default to prevent crashes.
    *   All exceptions must be properly categorized using custom exception classes with appropriate error context.
    *   Error formatting must be consistent and include relevant debugging information without exposing sensitive data.
    *   Retry decorators must handle transient failures gracefully with configurable backoff strategies.
5.  **Documentation Requirements:**
    *   All functions and classes must have comprehensive docstrings following the Google Python Style Guide.
    *   Full type hinting is required for all function signatures and variables.
    *   The logic for the cache complexity calculation must be clearly explained in the `should_use_cache` docstring.
    *   Exception classes must document their intended use cases and error context structure.
6.  **Compatibility Requirements:**
    *   Must support Python 3.9+ with appropriate type annotations and async/await syntax.
    *   Must be compatible with all supported Claude models and their respective tool capabilities.
    *   Must integrate seamlessly with the think tool capability and text_editor_20250124 tool requirements.

## Dependencies
Standard Library:
- `pathlib`: To handle file paths and retrieve file size for cache logic and path validation.
- `typing`: For full type hinting support (`Dict`, `Union`, `Literal`, `Optional`, `Any`, `Callable`, `TypeVar`, `Protocol`).
- `logging`: For structured logging infrastructure, warning about unknown model names, and async-safe logging operations.
- `asyncio`: For async operation support, timing utilities, and async-safe decorators.
- `functools`: For creating decorators (retry logic, performance timing) and wrapping functions.
- `time`: For performance timing measurements and retry backoff calculations.
- `re`: For input sanitization, path validation, and sensitive data filtering.
- `os`: For environment variable access and system path validation.
- `sys`: For system information and compatibility checks.
- `traceback`: For detailed error formatting and exception context preservation.
- `json`: For structured logging output and configuration serialization.

Third-party:
- None. This is a foundational utility module with no external dependencies to maintain maximum compatibility and minimize installation requirements.

Internal:
- None. This is a foundational utility module with no other internal dependencies, making it the first module to be implemented (priority 1 in architecture).

## Implementation Instructions

### 1. Type Aliases and Constants
*   **Type Aliases**: Define comprehensive type aliases at the module level:
    ```python
    FilePath = Union[str, Path]
    ModelName = str  # Support for Claude models with text editor capabilities
    CacheMode = Literal['auto', 'always', 'never']
    CacheStatus = Literal['none', 'write', 'read']
    EditInstruction = str
    LogLevel = Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']
    ```
*   **System Constants**: Define module-level constants for configuration:
    ```python
    # Cache thresholds - configurable via environment variables
    CACHE_SIZE_THRESHOLD_MIN = 1024  # 1KB
    CACHE_SIZE_THRESHOLD_MAX = 4096  # 4KB
    
    # Model compatibility mapping - maps models to their supported text editor tools
    TEXT_EDITOR_TOOL_VERSIONS = {
        # Claude 4 models support text_editor_20250728
        # Claude 3.7 models support text_editor_20250124  
        # Claude 3.5 models support text_editor_20241022
    }
    ```

### 2. Exception Classes
*   **Base Exception**: Define `EditToolError(Exception)` as the base exception class with error context support.
*   **Specific Exceptions**: Define specialized exception classes:
    - `FileOperationError(EditToolError)`: For file I/O related errors
    - `APIError(EditToolError)`: For Claude API communication errors  
    - `ValidationError(EditToolError)`: For input validation failures
    - `ModelCompatibilityError(EditToolError)`: For unsupported model/feature combinations
*   **Error Context**: Each exception should support structured error context with relevant debugging information.

### 3. Logging Infrastructure
*   **Logger Setup**: Create `setup_logger(name: str, level: LogLevel = 'INFO', structured: bool = False) -> logging.Logger`.
*   **Async Safety**: Ensure all logging operations are async-safe and non-blocking.
*   **Sanitization**: Implement `sanitize_for_logging(data: Any) -> Any` to remove sensitive information (API keys, file contents).
*   **Structured Output**: Support both human-readable and JSON structured logging formats.

### 4. Performance Decorators
*   **Retry Decorator**: Implement `@retry(max_attempts: int = 3, backoff_factor: float = 1.5, exceptions: Tuple[Type[Exception], ...] = (Exception,))`.
*   **Timing Decorator**: Implement `@timed(logger: Optional[logging.Logger] = None)` for performance measurement.
*   **Async Support**: Ensure decorators work with both sync and async functions using `functools.wraps` and proper async handling.

### 5. Validation Utilities
*   **Path Validation**: Implement `validate_file_path(path: FilePath, must_exist: bool = False, allow_create: bool = True) -> Path`.
*   **Model Compatibility**: Implement `check_model_compatibility(model: ModelName, feature: str) -> bool` to verify tool support.
*   **Input Sanitization**: Implement utilities to sanitize user inputs and prevent injection attacks.

### 6. Cost Management (Enhanced)
*   **`MODEL_PRICES` Constant**: Define comprehensive pricing dictionary with all supported models that have text editor capabilities:
    ```python
    MODEL_PRICES = {
        # Claude 4 models (text_editor_20250728)
        # Claude 3.7 models (text_editor_20250124)  
        # Claude 3.5 models (text_editor_20241022)
        # Structure: model_name -> {'input': price, 'output': price, 'cache_input_write': price, 'cache_input_read': price}
        # Cache pricing: write = input * 1.25, read = input * 0.10
    }
    ```
*   **Enhanced Cost Calculation**: Extend `calculate_cost` to support detailed breakdowns and cost reporting.
*   **Cost Formatting**: Implement `format_cost(cost: float, precision: int = 4) -> str` for consistent cost display.

### 7. Cache Strategy (Enhanced)
*   **Smart Detection**: Enhance `should_use_cache` with more sophisticated complexity analysis.
*   **Cache Metrics**: Implement functions to calculate and report cache effectiveness metrics.
*   **Configuration Support**: Support user-configurable cache thresholds and complexity parameters.

### 8. System Integration Utilities
*   **Environment Handling**: Implement utilities for reading configuration from environment variables.
*   **Compatibility Checks**: Implement functions to verify Python version, async support, and system requirements.
*   **Telemetry Hooks**: Provide hooks for future telemetry and diagnostics integration.

## Key Functions and Classes

### Exception Classes
```python
class EditToolError(Exception):
    """Base exception class for all edit-file-tool errors with structured context."""
    def __init__(self, message: str, context: Optional[Dict[str, Any]] = None):
        ...

class FileOperationError(EditToolError):
    """Exception for file I/O related errors."""
    ...

class APIError(EditToolError):
    """Exception for Claude API communication errors."""
    ...

class ValidationError(EditToolError):
    """Exception for input validation failures."""
    ...

class ModelCompatibilityError(EditToolError):
    """Exception for unsupported model/feature combinations."""
    ...
```

### Logging Infrastructure
```python
def setup_logger(
    name: str, 
    level: LogLevel = 'INFO', 
    structured: bool = False,
    log_file: Optional[FilePath] = None
) -> logging.Logger:
    """Sets up a configurable async-safe logger with structured output."""
    ...

def sanitize_for_logging(data: Any) -> Any:
    """Sanitizes data by removing sensitive information before logging."""
    ...

def get_logger(name: str) -> logging.Logger:
    """Gets or creates a logger instance for the specified module."""
    ...
```

### Performance Decorators
```python
def retry(
    max_attempts: int = 3,
    backoff_factor: float = 1.5,
    exceptions: Tuple[Type[Exception], ...] = (Exception,)
) -> Callable:
    """Decorator for retry logic with exponential backoff."""
    ...

def timed(logger: Optional[logging.Logger] = None) -> Callable:
    """Decorator for performance timing measurement."""
    ...

def async_safe(func: Callable) -> Callable:
    """Decorator to ensure function works safely in async contexts."""
    ...
```

### Validation Utilities
```python
def validate_file_path(
    path: FilePath, 
    must_exist: bool = False, 
    allow_create: bool = True
) -> Path:
    """Validates and normalizes file paths with security checks."""
    ...

def check_model_compatibility(model: ModelName, feature: str) -> bool:
    """Checks if a model supports specific features like text_editor_20250124."""
    ...

def sanitize_input(input_data: str, max_length: Optional[int] = None) -> str:
    """Sanitizes user input to prevent injection attacks."""
    ...
```

### Cost Management
```python
def get_model_prices(model: str) -> Dict[str, float]:
    """Retrieves pricing information for a given Anthropic model."""
    ...

def calculate_cost(
    model: str,
    input_tokens: int,
    output_tokens: int,
    cache_status: CacheStatus = "none"
) -> float:
    """Calculates the total cost of an LLM API call in USD."""
    ...

def format_cost(cost: float, precision: int = 4) -> str:
    """Formats cost values for consistent display."""
    ...

def calculate_cost_breakdown(
    model: str,
    input_tokens: int,
    output_tokens: int,
    cache_status: CacheStatus = "none"
) -> Dict[str, float]:
    """Provides detailed cost breakdown for analysis."""
    ...
```

### Cache Strategy
```python
def should_use_cache(file_path: FilePath, file_content: str) -> bool:
    """Determines whether to use prompt caching based on file size and complexity."""
    ...

def calculate_cache_complexity(content: str) -> float:
    """Calculates content complexity score for cache decision making."""
    ...

def estimate_cache_savings(
    file_size: int, 
    expected_requests: int = 2
) -> Dict[str, float]:
    """Estimates potential cost savings from caching."""
    ...
```

### System Integration
```python
def get_environment_config(key: str, default: Any = None) -> Any:
    """Retrieves configuration from environment variables with type conversion."""
    ...

def check_system_compatibility() -> Dict[str, bool]:
    """Checks system requirements and compatibility."""
    ...

def format_metrics(metrics: Dict[str, Any]) -> str:
    """Formats performance and cost metrics for display."""
    ...
```

## Deliverables
1.  **Complete Implementation**: A fully functional `edit_file_tool/utils.py` module that serves as the foundational utility layer for the entire edit-file-tool application.

2.  **Comprehensive Test Suite**: A corresponding unit test file `tests/test_utils.py` with extensive coverage including:
    *   **Exception Classes**: Tests for all custom exception classes, error context preservation, and inheritance hierarchy.
    *   **Logging Infrastructure**: Tests for logger setup, async safety, sanitization, and structured output formats.
    *   **Performance Decorators**: Tests for retry logic with various failure scenarios, timing accuracy, and async/sync compatibility.
    *   **Validation Utilities**: Tests for path validation (including security checks), model compatibility verification, and input sanitization.
    *   **Cost Management**: Tests for `calculate_cost` covering all `cache_status` options, model pricing accuracy, cost formatting, and detailed breakdowns.
    *   **Cache Strategy**: Tests for `should_use_cache` covering all three size brackets (small, medium, large), different complexity scenarios for medium-sized files, and cache effectiveness estimation.
    *   **System Integration**: Tests for environment configuration, compatibility checks, and metrics formatting.
    *   **Error Handling**: Tests verifying fallback behavior for unknown model names, graceful degradation, and proper error propagation.
    *   **Edge Cases**: Comprehensive coverage of boundary conditions, malformed inputs, and system limitations.

3.  **Type Safety**: Full type hints for all function signatures, variables, return values, and type aliases using modern Python typing features (3.9+ compatible).

4.  **Documentation Excellence**: 
    *   Google-style docstrings for the module and all public functions, classes, and methods.
    *   Clear explanations of complex logic (especially cache complexity calculation algorithms).
    *   Usage examples for key functions and decorators.
    *   Exception class documentation with intended use cases and error context structure.

5.  **Robust Error Handling**: 
    *   Graceful handling of all identified edge cases, particularly invalid model names, malformed inputs, and system compatibility issues.
    *   Consistent error formatting with appropriate debugging information while maintaining security.
    *   Proper exception categorization using the custom exception hierarchy.

6.  **Security Implementation**:
    *   Input sanitization functions that prevent injection attacks and directory traversal.
    *   Logging sanitization that removes sensitive information (API keys, file contents, system paths).
    *   Path validation with security checks against restricted system access.

7.  **Performance Optimization**:
    *   Minimal overhead implementations for all utility functions.
    *   Async-safe operations that don't block the event loop.
    *   Efficient decorators that add minimal performance impact.
    *   Memory-efficient data structures and algorithms.

8.  **Integration Readiness**:
    *   Constants and type aliases that support all higher-level modules in the architecture.
    *   Logging infrastructure that can be consistently used across all components.
    *   Exception classes that provide proper error context for debugging and user feedback.
    *   Utility functions that abstract common operations needed by file_io, claude_api, editor_tool, and other modules.

9.  **Future-Proofing**:
    *   Extensible design that supports adding new Claude models and pricing tiers.
    *   Hooks for telemetry and diagnostics integration.
    *   Configuration system that supports environment-based customization.
    *   Modular structure that facilitates maintenance and feature additions.

10. **Compatibility Assurance**:
    *   Python 3.9+ compatibility with appropriate async/await usage.
    *   Cross-platform compatibility (Windows, macOS, Linux).
    *   Integration readiness with all supported Claude models and their tool capabilities.
    *   Seamless integration with think tool and text_editor_20250124 requirements.