# Module: edit_file_tool/editor_tool.py

## Role and Responsibilities
This module provides the core implementation for the file editing capabilities of the `edit-file-tool`. Its primary purpose is to offer a safe, robust, and asynchronous Python interface that directly maps to the commands of a text editor tool API (version-agnostic).

This module acts as the "backend" for the LLM's tool-use requests, translating abstract commands like "replace this text" or "insert this line" into concrete, secure file system operations.

Key responsibilities include:
- Encapsulating all direct file system interactions (read, write, create, list).
- Implementing the logic for `view`, `str_replace`, `insert`, `create`, and `undo_edit` commands.
- Ensuring file operations are secure by validating paths and preventing directory traversal.
- Managing a simple backup system to support the `undo_edit` command.
- Returning structured, predictable results for both successful and failed operations.

## Requirements
1.  **Functional Requirements:**
    -   Implement a main editor tool class to contain all tool logic. Define the class as `EditTool20250124` (project convention used by README, examples, and tests).
    -   The class must have a main `async __call__` method that dispatches to the appropriate command handler based on a `command` string argument.
    -   **`view` command:**
        -   If the path is a file, it must return the file's content as a string, with each line prepended by its 1-indexed line number (e.g., "1: line content\n"). When `view_range=(start, end)` is provided, number the returned lines starting at `start`.
        -   If the path is a directory, it must return a string listing its contents, sorted lexicographically for deterministic output across platforms. Format the output exactly as: `Contents of directory '{path_str}':\n` followed by the entries joined with `\n`.
        -   If the target path does not exist, raise an error with the message: `Path '{path_str}' does not exist.`
        -   It must support an optional `view_range` tuple to view a specific range of lines.
    -   **`str_replace` command:**
        -   If the target path is not a file, raise an error with the message: `File not found at '{path_str}'.`
        -   It must replace a single, exact occurrence of `old_str` with `new_str`.
        -   It must return an error if zero or more than one occurrences of `old_str` are found in the file, to prevent unintended edits (e.g., "not found" or "Found {count} occurrences of '{old_str}'").
    -   **`insert` command:**
        -   If the target path is not a file, raise an error with the message: `File not found at '{path_str}'.`
        -   It must insert `new_str` into the file at the specified `insert_line`.
        -   `insert_line=0` must insert the content at the beginning of the file.
        -   `insert_line=N` (for N > 0) must insert the content *after* line N.
        -   If `insert_line > len(lines)`, return an error: `Invalid insert_line {N}. File only has {len} lines.`
    -   **`create` command:**
        -   It must create a new file at the specified path with the provided `file_text`.
        -   It must return an error if the file already exists.
    -   **`undo_edit` command:**
        -   It must revert the last successful modification made to a specific file.
        -   It must handle cases where no backup is available for a file (e.g., "No backup available for '{path_str}'"). A second undo attempt must fail.
2.  **Performance Requirements:**
    -   All file I/O operations must be fully asynchronous and non-blocking. Use the provided async I/O helpers from the `<file_io_example>` below.
3.  **Security Requirements:**
    -   All file paths must be validated to enforce these behaviors:
        -   Forbid absolute paths. Raise `PermissionError` with a message that includes: "is an absolute path and is outside the allowed directory."
        -   Prevent directory traversal: resolve the path against the current working directory (CWD) and ensure it remains within CWD; otherwise raise `PermissionError` including: "is outside the allowed directory."
        -   On non-Windows systems (POSIX), before converting to `Path`, reject Windows-style absolute paths (e.g., strings matching `^[A-Za-z]:[\\/]` ), and raise `PermissionError` with a message that includes: "appears to be a Windows absolute path and is outside the allowed directory."
    -   File operations must be restricted to the current working directory and its subdirectories only.
4.  **Error Handling Requirements:**
    -   The tool must not crash on file system errors like `FileNotFoundError` or `PermissionError`.
    -   All public methods must return a standardized `EditResult` object.
    -   The `EditResult` object must clearly indicate success or failure and provide a descriptive error message in case of failure. Prefer using the custom `EditToolError` from `edit_file_tool/utils.py` for tool-specific errors.
5.  **Documentation Requirements:**
    -   The module, all classes, and all public methods must have comprehensive Google-style docstrings.
    -   Full type hints are required for all function signatures and class attributes.

## Dependencies
Standard Library:
-   `asyncio`
-   `pathlib`
-   `typing` (specifically `Optional`, `Tuple`, `Dict`, `List`)
-   `dataclasses`
-   `os`

Internal:
-   `edit_file_tool/file_io.py`
-   `edit_file_tool/utils.py`

% Here are examples of how to use internal modules:
<internal_example_modules>
    % Here is an example of the async file I/O functions that should be used for reading and writing files.
    <file_io_example>
        <include>examples/file_io_example.py</include>
    </file_io_example>

    % Here is an example of the utility functions, such as path validation and custom exceptions, that should be preferred as per the prompt's instructions.
    <utils_example>
        <include>examples/utils_example.py</include>
    </utils_example>
</internal_example_modules>

### Exceptions and Holds Fallbacks
- Use the provided `EditToolError` from the `<utils_example>` below. Do not define local fallback exceptions.

## Implementation Instructions
1.  **`EditResult` Dataclass:**
    -   Define a dataclass named `EditResult` to serve as the standard return type for all tool operations.
    -   It should contain the fields: `success: bool`, `output: str`, and `error: Optional[str] = None`.

2.  **`EditTool20250124` Class:**
    -   Define the main class `EditTool20250124`.
    -   In the `__init__` method, initialize a dictionary `self.backups: Dict[pathlib.Path, str] = {}` to store the original content of files before they are modified. The key should be the resolved `pathlib.Path` object.

3.  **Path Validation:**
    -   Implement a private helper method (e.g., `_validate_path(self, path_str: str) -> pathlib.Path`).
    -   This method should:
        -   On non-Windows systems (POSIX), before converting to `Path`, detect Windows-style absolute paths (e.g., `^[A-Za-z]:[\\/]` ), and raise `PermissionError` including: "appears to be a Windows absolute path and is outside the allowed directory."
        -   Convert the input string to a `pathlib.Path` object.
        -   Forbid absolute paths: if `path.is_absolute()` raise `PermissionError` including: "is an absolute path and is outside the allowed directory."
        -   Resolve the path against the current working directory and ensure it remains within CWD; if it does not, raise `PermissionError` including: "is outside the allowed directory."
        -   Return the resolved, validated `pathlib.Path` object.

4.  **Backup Mechanism:**
    -   Implement a private async helper method `_backup_file(self, path: pathlib.Path)`.
    -   This method should be called *before* any file modification (`str_replace`, `insert`).
    -   It should read the entire content of the file at `path` using the async I/O functions from the `<file_io_example>` below and store it in `self.backups`, keyed by the `path` object.

5.  **Main Dispatcher (`__call__`):**
    -   Implement an async `__call__` method to make the class instance callable.
    -   It should accept `command: str`, `path: str`, and `**kwargs`.
    -   Use a `match` statement or `if/elif/else` block on the `command` argument to delegate to the corresponding async method (e.g., `self.view`, `self.str_replace`).
    -   Wrap the delegation logic in a `try...except` block to catch common exceptions like `FileNotFoundError`, `PermissionError`, `ValueError`, and the custom `EditToolError`, returning an appropriate `EditResult(success=False, ...)` for each.

6.  **Command Implementations:**
     -   **IMPORTANT**: For all file reading and writing, you must use the async helper functions `read_file_async` and `write_file_async` from `edit_file_tool/file_io.py`.
     -   Implement each command as a separate async method. Each method should first call the path validation helper.
     -   `view`:
         -   If path is a directory, list entries, sort lexicographically, and format as: `Contents of directory '{path_str}':\n` + `"\n".join(entries)`.
         -   If path is a file, use `read_file_async` to read the content, split into lines, and format by numbering lines starting at 1, or at `view_range[0]` when `view_range` is provided. Handle the `view_range` parameter if provided.
         -   If the target path does not exist, return an error with the string: `Path '{path_str}' does not exist.`
     -   `str_replace`:
         -   Validate that the target is a file; otherwise return an error: `File not found at '{path_str}'.`
         -   Call `await self._backup_file(path)`.
         -   Read file content. Count occurrences of `old_str`.
         -   If count is not 1, return an `EditResult` with an informative error.
         -   If count is 1, perform replacement and use `write_file_async` to write the new content back. Return a success `EditResult`.
     -   `async def insert(...)`:
         -   Validate that the target is a file; otherwise return an error: `File not found at '{path_str}'.`
         -   Call `await self._backup_file(path)`.
         -   Read file content using `read_file_async` and split into a list of lines.
         -   Calculate the correct insertion index. `insert_line=0` means index 0. `insert_line=5` means index 5 (to insert after line 5).
         -   Use `list.insert()` to add the `new_str`.
         -   If `insert_line > len(lines)`, return an error: `Invalid insert_line {N}. File only has {len} lines.`
         -   Join the lines and write back to the file using `write_file_async`. Return a success `EditResult`.
     -   `async def create(...)`:
         -   Validate the path. Check if it already exists using `path.exists()`. If so, return an error.
         -   Use `write_file_async` to write the `file_text` to the new file. Return a success `EditResult`.
     -   `async def undo_edit(...)`:
         -   Validate the path.
         -   Check if `path` exists as a key in `self.backups`. If not, return an error `EditResult` (e.g., "No backup available for '{path_str}'"). A second undo attempt must fail.
         -   Use `write_file_async` to write the backed-up content from `self.backups[path]` back to the file.
         -   Remove the entry from `self.backups` upon successful restoration.
         -   Return a success `EditResult`.

## Key Functions and Classes
-   **`EditResult` (or equivalent result type)**
    -   Must clearly indicate success or failure
    -   Should include a user-facing output string
    -   May include an optional error message

-   **Main Editor Tool Class**
    -   `__init__(self)`
    -   `async __call__(self, command: str, path: str, **kwargs) -> EditResult`
    -   `async view(self, path: str, view_range: Optional[Tuple[int, int]] = None) -> EditResult`
    -   `async str_replace(self, path: str, old_str: str, new_str: str) -> EditResult`
    -   `async insert(self, path: str, insert_line: int, new_str: str) -> EditResult`
    -   `async create(self, path: str, file_text: str) -> EditResult`
    -   `async undo_edit(self, path: str) -> EditResult`
    -   `path` validation helper (private)
    -   backup helper (private, async)

## Deliverables
1.  A complete, production-ready implementation of the `edit_file_tool/editor_tool.py` module containing the `EditResult` type and the main editor tool class as specified.
2.  Full type hints for all function signatures, variables, and class members.
3.  Google-style docstrings for the module, class, and all public methods.
4.  Robust error handling for all identified edge cases, such as file not found, permission errors, and invalid command parameters.

## Implementation Guidance (No Hardcoded Implementations)
- Do not embed concrete code or hardcode library choices in this prompt. Instead, describe behavior, contracts, and constraints.
- Prefer prompts and configuration for naming, dependency selection, and command wiring.
- Use the provided utility modules instead of creating fallbacks.