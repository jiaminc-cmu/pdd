# Module: {placeholder}

## Context
<required_context_files>
  % Architecture defines ownership and entry-points.
  <architecture>
    <include>pdd/architecture.json</include>
  </architecture>

  % CLI module provides the console entry point target.
  <cli>
    <include>edit_file_tool/cli.py</include>
  </cli>

  % Project dependencies (names and versions) to avoid hardcoding.
  <dependencies>
    <include>project_dependencies.csv</include>
  </dependencies>

  % README content for long_description/readme field.
  <readme>
    <include>EDIT_FILE_TOOL_README.md</include>
  </readme>
</required_context_files>

## Role and Responsibilities
[Generate a valid `pyproject.toml` manifest for packaging and distribution of the `edit-file-tool` project. Do not include any runtime logic, API calls, or environment-variable handling. Focus on build system configuration, project metadata, dependencies, and console scripts consistent with the architecture.]

## Requirements

### Build System
1.  Define a `[build-system]` table using a modern backend (prefer `hatchling` or `setuptools`), with appropriate `requires` and `build-backend` fields. Avoid hardcoding versions when not necessary.

### Project Metadata (`[project]`)
1.  `name`: Use a canonical package name (e.g., `edit-file-tool`).
2.  `version`: Prefer dynamic (managed by VCS/tagging or backend features); avoid hardcoding a specific version unless explicitly provided by context.
3.  `description`: A concise summary sourced from the README context.
4.  `readme`: Reference the included file from `<readme>` (e.g., `EDIT_FILE_TOOL_README.md`). Do not assume `README.md`.
5.  `requires-python`: `>=3.9`.
6.  `authors`: Provide at least one author entry with name/email (use context if available; otherwise reasonable placeholder).
7.  `license`: Use an SPDX identifier or reference a `LICENSE` file if present; do not embed license text unless required.
8.  `classifiers`: Include appropriate Trove classifiers (Programming Language :: Python :: 3, License, OS Independent, etc.).
9.  `dependencies`: Build strictly from `project_dependencies.csv` (names and pinned versions). Do not hardcode package names/versions in the TOML content beyond what the CSV specifies.
10. `urls` (optional): Only include when actual URLs are provided in context; avoid placeholders.

### Console Scripts (`[project.scripts]`)
1.  Register exactly one CLI entry point per architecture:
    - `edit-file = edit_file_tool.cli:main`
2.  Do not add additional scripts or point to non-existent modules.

### Optional Dependencies (`[project.optional-dependencies]`)
1.  If applicable, define extras (e.g., `dev`, `test`) using `project_dependencies.csv` entries; avoid hardcoding.

### Packaging Configuration
1.  Ensure only the `edit_file_tool` package is included in wheels.
2.  Exclude tests/examples and other non-runtime directories from the sdist by default.
3.  For Hatchling, set:
    - `[tool.hatch.build.targets.wheel].packages = ["edit_file_tool"]`
    - `[tool.hatch.build.targets.sdist].exclude = ["/tests", "/examples", "/docs", "/.github", "/*.log"]`
   For Setuptools, use equivalent package discovery/manifest settings.

## Prohibited Behaviors
- Do not include any model/tool configuration, prompt caching policy, cost tracking, or any runtime logic. Those belong to code modules (`claude_api.py`, `core.py`).
- Do not read environment variables (e.g., `ANTHROPIC_API_KEY`).
- Do not declare API usage or retries in this manifest.
 - Do not include placeholder URLs or metadata not grounded in provided context.

## Implementation Instructions
1.  Read `project_dependencies.csv` to assemble the `dependencies` list with pinned versions as provided. Do not invent or hardcode versions outside of the CSV.
2.  Set exactly one console script: `edit_file_tool.cli:main` per the architecture.
3.  Choose a build backend (Hatchling or Setuptools) and declare its minimal required version in `[build-system].requires`.
4.  Populate `[project]` fields using the included README path for `readme` and its summary for `description`.
5.  Configure package inclusion/exclusion explicitly for the chosen backend (e.g., Hatchling `[tool.hatch.build.targets.*]`).
6.  Avoid adding sections unrelated to packaging (no runtime/tool settings, no env handling).

## Key Tables and Fields (TOML)
- `[build-system]`: `requires`, `build-backend`.
- `[project]`: `name`, `version` (or dynamic), `description`, `readme`, `requires-python`, `authors`, `license`, `classifiers`, `dependencies`, `urls` (optional).
- `[project.scripts]`: `edit-file = edit_file_tool.cli:main`.
- `[tool.<backend>]`: Backend-specific packaging settings (e.g., package discovery). Keep minimal and aligned with chosen backend.

## Deliverables
1.  A complete, valid `pyproject.toml` manifest for the package, aligned with the architecture and sourcing dependency versions from `project_dependencies.csv`.
2.  No unit tests or runtime code here; this file is configuration only.